kubetorchConfig:
  serviceAccountAnnotations: {}
  # List of namespaces to allow deploying compute resources to
  deployment_namespaces:
    - "default"
    - "kubetorch"
  otelEnabled: true # Allows OTEL on the server, necessary for enabling TTL

nginx:
  # if using a custom DNS resolver, update the value below (e.g., "coredns.kube-system.svc.cluster.local")
  resolver: "kube-dns.kube-system.svc.cluster.local"

nvidia-device-plugin:
  enabled: true # set to `false` to disable GPU support
  namespaceOverride: "kubetorch"
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: nvidia.com/gpu.product
                operator: Exists

  tolerations:
    - key: "nvidia.com/gpu"
      operator: "Exists"
      effect: "NoSchedule"
    - key: "dedicated"
      operator: "Equal"
      value: "gpu"
      effect: "NoSchedule"

dataStore:
  image: ghcr.io/run-house/kubetorch-data-store:v1
  imagePullPolicy: Always
  # serviceAccount: kubetorch-service-account  # Optional: use specific service account for Workload Identity
  maxConnections: 500  # Maximum concurrent rsync connections (increase for many worker pods)
  timeout: 600  # Connection timeout in seconds
  maxVerbosity: 0  # Log verbosity (0-4, use 0 for production, higher for debugging)
  maxConnectionsPerModule: 0  # Per-module limit (0 = unlimited, inherits global limit)
  cpu:
    request: 1
  memory:
    request: 4Gi
    limit: 8Gi
  ephemeralStorage: # adjust based on expected node disk size
    request: 5Gi
    limit: 10Gi
  storage:
    size: 100Gi  # Size of persistent volume
    storageClassName: ""  # Leave empty to use default storage class
  cleanupCron:
    enabled: false # set to true to enable pod cleanup
  tolerations: []
  affinity: {}

controller:
  image: ghcr.io/run-house/kubetorch-controller
  tag: consolidate-service-managers # TODO: flip to main
  imagePullPolicy: Always # TODO: use IfNotPresent

  servicePort: 8080  # Port the controller service is exposed on (via nginx)
  port: 8081  # Internal port the controller listens on
  workers: 8  # Number of Uvicorn worker processes (each handles ~10 concurrent requests)
  connectionPoolSize: 20  # K8s API connection pool size per worker
  storage:
    size: "1Gi"  # Size of the PVC for controller state
    # storageClassName: ""  # Optional: specify a storage class (defaults to cluster default)

  resources:
    cpu:
      request: "200m"   # Minimum guaranteed CPU (0.2 cores)
      limit: "2000m"    # Maximum burst CPU (2 cores) for 8 workers
    memory:
      request: "1Gi"    # Minimum guaranteed memory
      limit: "2Gi"      # Maximum memory for 8 workers + connection pools + headroom

  tolerations: []
  affinity: {}

nginxProxy:
  image:
    repository: nginx
    tag: 1.29.0-alpine
    pullPolicy: IfNotPresent
  maxBodySize:
    rsync: "10G" # 10GB max body size for rsync operations (e.g. large data transfers)
    api: "250M"  # 250MB max body size for all other routes
  backends:
    logging:
      route: "/loki"
    health:
      route: "/health"
  resources:
    cpu:
      request: "200m"   # Minimum guaranteed CPU (0.2 cores)
      limit: "1"        # Maximum CPU (1 core)
    memory:
      request: "256Mi"  # Minimum guaranteed memory
      limit: "512Mi"    # Maximum memory - handles 1000+ concurrent connections
  tolerations: []
  affinity: {}

logStreaming:
  enabled: true # set to `false` to disable log streaming
  retentionPeriod: 24h
  maxConcurrentTailRequests: 100
  image: grafana/loki:3.5.3
  port: 3100
  resources:
    cpu: 100m
    memory: 256Mi

metrics:
  enabled: true # set to `false` to disable metrics collection & streaming
  scrapeKubelet: true
  prometheus:
    image: prom/prometheus:v3.7.2
    port: 9090
    retention: 24h
    scrapeInterval: 3s
    resources:
      cpu: 200m
      memory: 512Mi
    additionalScrapeConfigs:
      - job_name: "gke-managed-dcgm"
        honor_labels: true
        kubernetes_sd_configs:
          - role: pod
            namespaces:
              names: ["gke-managed-system"]
        relabel_configs:
          - source_labels: [__meta_kubernetes_pod_name]
            regex: "dcgm-exporter.*"
            action: keep
          - source_labels: [__meta_kubernetes_pod_container_port_number]
            regex: "9400"
            action: keep
          - source_labels: [__meta_kubernetes_pod_ip]
            target_label: __address__
            replacement: "$1:9400"
          - source_labels: [__meta_kubernetes_namespace]
            target_label: namespace
          - source_labels: [__meta_kubernetes_pod_name]
            target_label: pod

opentelemetry-collector:
  enabled: true # set to `false` to disable opentelemetry collector
  serviceAccount:
    create: false # use the SA that kubetorch creates
    name: kubetorch-opentelemetry-collector
  mode: daemonset
  image:
    repository: otel/opentelemetry-collector-contrib
    pullPolicy: IfNotPresent
  presets:
    logsCollection:
      enabled: true
      includeCollectorLogs: true
    kubernetesAttributes:
      enabled: true
      extractAllPodLabels: true
    kubernetesEvents:
      enabled: true
  configMap:
    create: false
    existingName: otel-collector-config
  affinity: {}
  tolerations:
    - operator: "Exists"
      # This single toleration with operator: Exists and no key/value/effect
      # means "tolerate all taints" - the collector will run on every node
      # regardless of any taints, including GPU nodes, spot instances,
      # preemptible nodes, dedicated nodes, etc.


dcgm-exporter:
  enabled: false # set to `true` if deploying an EKS or rolling your own DCGM metrics collection
  namespaceOverride: "kubetorch"
  serviceMonitor:
    enabled: false  # kubetorch deploys its own service monitoring deployment

  image:
    repository: nvcr.io/nvidia/k8s/dcgm-exporter
    tag: 4.4.1-4.6.0-ubuntu22.04

  readinessProbe:
    enabled: false

  tolerations:
    - key: "nvidia.com/gpu"
      operator: "Exists"
      effect: "NoSchedule"

  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          # AWS GPUs
          - matchExpressions:
              - key: karpenter.k8s.aws/instance-gpu-manufacturer
                operator: In
                values: ["nvidia"]
              - key: karpenter.k8s.aws/instance-gpu-name
                operator: In
                values: ["a10g", "a100", "t4"]
          # Fallback: any node with a GPU
          - matchExpressions:
              - key: nvidia.com/gpu.present
                operator: Exists

ttlController:
  enabled: true
  # Namespaces to watch (creates Role + RoleBinding for each)
  namespaces: [] # Empty defaults to watching all namespaces in kubetorchConfig.deployment_namespaces
  # Prometheus URL and namespace for the TTL Controller to query metrics
  prometheusUrl: "http://kubetorch-metrics.kubetorch.svc.cluster.local:9090"
  prometheusNamespace: "kubetorch"
  # PodMonitor for Prometheus Operator (only needed if using kube-prometheus-stack)
  # kubetorch-metrics already scrapes these pods, so disabled by default
  podMonitor:
    enabled: false
    additionalLabels: {}
    prometheusLabel: "kube-prometheus" # Label to match your Prometheus Operator instance
  # Network Policy to allow egress to Prometheus (needed if cluster has default-deny policies)
  networkPolicy:
    enabled: false
    ports:
      - protocol: TCP
        port: 9090
